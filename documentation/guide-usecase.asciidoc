:toc: macro
toc::[]

= UseCase
A use-case is a small unit of the link:guide-logic-layer.asciidoc[logic layer] responsible for an operation on a particular link:guide-jpa.asciidoc#entity[entity] (business object).
We leave it up to you to decide whether you want to define an interface (API) for each use-case or provide an implementation directly.

Following our architecture-mapping (for link:guide-structure-classic.asciidoc#architecture-mapping[classic] and link:guide-structure-modern.asciidoc#architecture-mapping[modern] project), use-cases are named `Uc«Operation»«BusinessObject»[Impl]`. The prefix `Uc` stands for use-case and allows to easily find and identify them in your IDE. The `«Operation»` stands for a verb that is operated on the entity identified by `«BusinessObject»`.
For https://en.wikipedia.org/wiki/Create,_read,_update_and_delete[CRUD] we use the standard operations `Find` and `Manage` that can be generated by https://github.com/devonfw/cobigen[CobiGen]. This also separates read and write operations (e.g. if you want to do CQSR, or to configure read-only transactions for read operations).

In our example, we choose to define an interface for each use-case.

== Find
The `UcFind«BusinessObject»` defines all read operations to retrieve and search the `«BusinessObject»`.
Here is an example:
[source,java]
----
public interface UcFindBooking {

  BookingEto findBooking(Long id);

  BookingCto findBookingCto(Long id);

  Page<BookingEto> findBookingEtos(BookingSearchCriteriaTo criteria);

  Page<BookingCto> findBookingCtos(BookingSearchCriteriaTo criteria);

}
----

== Manage
The `UcManage«BusinessObject»` defines all CRUD write operations (create, update and delete) for the `«BusinessObject»`.
Here is an example:
[source,java]
----
public interface UcManageBooking {

  BookingEto saveBooking(BookingEto booking);

  boolean deleteBooking(Long id);

}
----

== Custom
Any other non CRUD operation `Uc«Operation»«BusinessObject»` uses any other custom verb for `«Operation»`.
Typically, such custom use-cases only define a single method.
Here is an example:
[source,java]
----
public interface UcApproveBooking {

  void approveBooking(BookingEto booking);

}
----

== Implementation
For the implementation of a use-case, the same rules that are described for the link:guide-component-facade.asciidoc#implementation[component-facade implementation].

In short, the implementation should carry its own name and the suffix `Impl` and is annotated with `@Named`. It will need access to the persistent data which is done by injecting the corresponding repository (or DAO). Furthermore, it shall not expose persistent entities from the data access layer and has to map them to transfer objects using the bean-mapper. Please refer to our bean mapping documentation for more information.
Here is an example:
[source,java]
----
public class UcFindBookingImpl implements UcFindBooking {

  @Inject
  private BookingRepository bookingRepository;

  @Override
  public BookingEto findBooking(Long id) {

    LOG.debug("Get Booking with id {} from database.", id);
    BookingEntity entity = this.bookingRepository.findOne(id);
    return getBeanMapper().map(entity, BookingEto.class));
  }
}
----

The use-cases can then be injected directly into the service.

[source,java]
----
@Named("BookingmanagementRestService")
@Validated
public class BookingmanagementRestServiceImpl implements BookingmanagementRestService {

  @Inject
  private UcFindBooking ucFindBooking;

  @Inject
  private UcManageBooking ucManageBooking;

  @Inject
  private UcApproveBooking ucApproveBooking;
}
----

== Internal use case
Sometimes, a component with multiple related entities and many use-cases needs to reuse business logic internally.
Of course, this can be exposed as an official use-case API but this will imply using transfer-objects (ETOs) instead of entities. In some cases, this is undesired e.g. for better performance to prevent unnecessary mapping of entire collections of entities.
In the first place, you should try to use abstract base implementations providing reusable methods the actual use-case implementations can inherit from.
If your business logic is even more complex and you have multiple aspects of business logic to share and reuse but also run into multi-inheritance issues, you may also just create use-cases that have their interface located in the `impl` scope package right next to the implementation (or you may just skip the interface). In such a case, you may define methods that directly take or return entity objects.
To avoid confusion with regular use-cases, we recommend to add the `Internal` suffix to the type name leading to `Uc«Operation»«BusinessObject»Internal[Impl]`.
